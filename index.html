<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>アイスタ カメラスキャン</title>
  <script charset="utf-8" src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      overflow: hidden;
      background: #000;
    }
    
    .screen {
      display: none;
      width: 100vw;
      height: 100vh;
      height: 100dvh; /* 動的ビューポート */
      flex-direction: column;
    }
    
    .screen.active {
      display: flex;
    }
    
    /* カメラ画面 */
    #camera-screen {
      background: #000;
      position: relative;
    }
    
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: transparent;
      padding: 15px;
      color: #fff;
      text-align: center;
      font-size: 16px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      text-shadow: 0 2px 8px rgba(0,0,0,0.8);
    }
    
    #camera-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
    }
    
    .camera-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: auto;
      background: transparent;
      padding: 30px 20px;
      text-align: center;
      z-index: 100;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 15px;
    }
    
    .hint {
      color: #fff;
      font-size: 12px;
      margin-bottom: 15px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8); /* 視認性向上 */
      background: rgba(0,0,0,0.6); /* ヒントテキストに背景 */
      padding: 8px 12px;
      border-radius: 4px;
    }
    
    #shutter-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: #fff;
      border: 4px solid #333;
      cursor: pointer;
      transition: transform 0.1s;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5); /* 影で浮き上がらせる */
    }
    
    #shutter-btn:active {
      transform: scale(0.95);
    }
    
    /* 編集画面 */
    #preview-screen {
      background: #222;
    }
    
    .preview-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    
    #preview-canvas {
      max-width: 100%;
      max-height: 100%;
      touch-action: none;
    }
    
    .edit-controls {
      flex-shrink: 0;
      background: #1a1a1a;
      padding: 20px;
    }
    
    .control-group {
      margin-bottom: 20px;
    }
    
    .control-label {
      color: #fff;
      font-size: 14px;
      margin-bottom: 8px;
      display: block;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    #brightness-slider {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: #444;
      outline: none;
      -webkit-appearance: none;
    }
    
    #brightness-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
    }
    
    #brightness-value {
      color: #fff;
      font-size: 14px;
      min-width: 40px;
      text-align: right;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    
    .btn:active {
      opacity: 0.7;
    }
    
    .btn-secondary {
      background: #444;
      color: #fff;
    }
    
    .btn-primary {
      background: #06c755;
      color: #fff;
      font-weight: bold;
    }
    
    /* 処理中画面 */
    #processing-screen {
      background: #fff;
      align-items: center;
      justify-content: center;
    }
    
    .spinner {
      width: 60px;
      height: 60px;
      border: 4px solid #f0f0f0;
      border-top-color: #06c755;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .processing-text {
      font-size: 16px;
      color: #333;
      margin-bottom: 10px;
    }
    
    .processing-hint {
      font-size: 12px;
      color: #999;
    }
    
    /* 完了画面 */
    #complete-screen {
      background: #fff;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
    }
    
    .complete-title {
      font-size: 24px;
      font-weight: bold;
      color: #333;
      margin-bottom: 10px;
    }
    
    .complete-message {
      font-size: 14px;
      color: #666;
      text-align: center;
      margin-bottom: 30px;
    }
    
    .action-btn {
      width: 200px;
      padding: 15px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
    }
    
    .action-btn-primary {
      background: #06c755;
      color: #fff;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    /* エラー画面 */
    #error-screen {
      background: #fff;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
    }
    
    .error-title {
      font-size: 24px;
      font-weight: bold;
      color: #e74c3c;
      margin-bottom: 10px;
    }
    
    .error-detail {
      font-size: 14px;
      color: #666;
      text-align: center;
      margin-bottom: 30px;
      padding: 0 20px;
    }
  </style>
</head>
<body>

  <!-- カメラ画面 -->
  <div id="camera-screen" class="screen">
    <div class="header">カメラスキャン</div>
    <video id="camera-preview" autoplay playsinline></video>
    <div class="camera-controls">
      <div class="hint">アイスタに聞きたい箇所を撮影してください。</div>
      <button id="shutter-btn"></button>
    </div>
  </div>

  <!-- 編集画面 -->
  <div id="preview-screen" class="screen">
    <div class="header">編集</div>
    <div class="preview-container">
      <canvas id="preview-canvas"></canvas>
    </div>
    <div class="edit-controls">
      <div class="control-group">
        <label class="control-label">明るさ</label>
        <div class="slider-container">
          <input type="range" id="brightness-slider" min="50" max="150" value="100">
          <span id="brightness-value">100%</span>
        </div>
      </div>
      <div class="button-group">
        <button class="btn btn-secondary" id="rotate-btn">🔄 回転</button>
        <button class="btn btn-secondary" id="retake-btn">📷 撮り直し</button>
      </div>
      <button class="btn btn-primary" id="send-btn">✅ この内容で送信</button>
    </div>
  </div>

  <!-- 処理中画面 -->
  <div id="processing-screen" class="screen">
    <div class="spinner"></div>
    <div class="processing-text">文字起こし中...</div>
    <div class="processing-hint">20〜40秒ほどお待ちください</div>
  </div>

  <!-- 完了画面 -->
  <div id="complete-screen" class="screen">
    <div class="complete-title">処理完了</div>
    <div class="complete-message">
      文字起こし結果をLINEで送信しました。<br>
      トークをご確認ください。
    </div>
    <button class="action-btn action-btn-primary" id="new-scan-btn">新しくスキャン</button>
  </div>

  <!-- エラー画面 -->
  <div id="error-screen" class="screen">
    <div class="error-title" id="error-title">エラーが発生しました</div>
    <div class="error-detail" id="error-detail"></div>
    <button class="action-btn action-btn-primary" id="retry-btn">もう一度試す</button>
  </div>

  <script>
    // ========================================
    // 設定
    // ========================================
    const LIFF_ID = '2008304828-OnEyAwBm';
    const WORKER_URL = 'https://aista-document-processor.luminalice-reg-tea-sun-red-9b0.workers.dev/upload-image';
    const DEBUG_MODE = true;

    // ========================================
    // 状態管理
    // ========================================
    let userId = null;
    let displayName = null;
    let cameraStream = null;
    let originalCanvas = null;
    let cropArea = null;
    let rotation = 0;
    let brightness = 1.0;
    let isDragging = false;
    let dragTarget = null;
    let dragStartX = 0;
    let dragStartY = 0;
    let cameraInitialized = false;
    let cameraPermissionState = 'unchecked'; // 'unchecked' | 'granted' | 'denied'

    // ========================================
    // ユーティリティ
    // ========================================
    function debugLog(message) {
      if (DEBUG_MODE) {
        const timestamp = new Date().toLocaleTimeString('ja-JP');
        console.log(`[${timestamp}] ${message}`);
      }
    }

    function showScreen(screenId) {
      debugLog(`画面遷移: ${screenId}`);
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(screenId).classList.add('active');
    }

    function showError(title, detail) {
      debugLog(`エラー表示: ${title} - ${detail}`);
      document.getElementById('error-title').textContent = title;
      document.getElementById('error-detail').textContent = detail;
      showScreen('error-screen');
    }

    // ========================================
    // STEP 2: LIFF初期化
    // ========================================
    async function initLiff() {
      try {
        debugLog('LIFF初期化開始...');
        await liff.init({ liffId: LIFF_ID });
        
        if (!liff.isLoggedIn()) {
          debugLog('未ログイン → ログイン実行');
          liff.login();
          return false;
        }
        
        const profile = await liff.getProfile();
        userId = profile.userId;
        displayName = profile.displayName;
        debugLog(`✅ ユーザー情報取得: ${displayName} (${userId})`);
        
        return true;
      } catch (error) {
        debugLog(`❌ LIFF初期化エラー: ${error.message}`);
        showError('LIFF初期化エラー', 'LINEからアクセスしてください。');
        return false;
      }
    }

    // ========================================
    // STEP 3: カメラ起動
    // ========================================
    async function checkCameraPermission() {
      // Permissions APIで事前確認
      if (navigator.permissions && navigator.permissions.query) {
        try {
          const result = await navigator.permissions.query({ name: 'camera' });
          debugLog(`カメラ権限状態: ${result.state}`);
          
          if (result.state === 'granted') {
            return 'granted';
          } else if (result.state === 'denied') {
            return 'denied';
          }
          return 'unchecked';
        } catch (e) {
          debugLog('Permissions API非対応');
          return 'unchecked';
        }
      }
      return 'unchecked';
    }

    async function initCamera() {
      // 既にストリームがある場合は再利用
      if (cameraStream && cameraInitialized) {
        debugLog('カメラストリーム再利用');
        const video = document.getElementById('camera-preview');
        video.srcObject = cameraStream;
        return;
      }
      
      // 拒否状態の場合は案内画面のみ
      if (cameraPermissionState === 'denied') {
        debugLog('カメラ拒否済み - 案内表示');
        showCameraPermissionGuide();
        return;
      }
      
      // 事前チェック（初回 or リトライ時）
      if (cameraPermissionState === 'unchecked') {
        const preCheckState = await checkCameraPermission();
        if (preCheckState === 'denied') {
          cameraPermissionState = 'denied';
          showCameraPermissionGuide();
          return;
        }
      }
      
      try {
        debugLog('カメラ初期化開始...');
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          }
        });
        
        cameraStream = stream;
        cameraPermissionState = 'granted';
        cameraInitialized = true;
        
        const video = document.getElementById('camera-preview');
        video.srcObject = stream;
        
        // メタデータ読み込み後のデバッグ情報
        video.addEventListener('loadedmetadata', () => {
          debugLog(`Video size: ${video.videoWidth}x${video.videoHeight}`);
          const controls = document.querySelector('.camera-controls');
          const rect = controls.getBoundingClientRect();
          debugLog(`Controls position: top=${rect.top}, bottom=${rect.bottom}`);
          debugLog(`Controls visible: ${rect.bottom <= window.innerHeight}`);
        }, { once: true });
        
        debugLog('✅ カメラ起動成功');
      } catch (error) {
        handleCameraError(error);
      }
    }

    function handleCameraError(error) {
      debugLog(`カメラエラー: ${error.name} - ${error.message}`);
      
      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
        // 拒否された
        cameraPermissionState = 'denied';
        showCameraPermissionGuide();
        
      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
        // カメラが見つからない
        showError(
          'カメラが見つかりません',
          'お使いの端末にはカメラが搭載されていないか、接続されていません。'
        );
        
      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
        // カメラが他のアプリで使用中
        showError(
          'カメラにアクセスできません',
          '他のアプリがカメラを使用している可能性があります。\n他のアプリを終了してから再度お試しください。'
        );
        
      } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
        // 要求された条件を満たせない
        debugLog('カメラ条件を緩和して再試行...');
        retryWithLowerConstraints();
        
      } else {
        // その他のエラー
        showError('カメラエラー', error.message);
      }
    }

    async function retryWithLowerConstraints() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: true // 最小限の設定
        });
        cameraStream = stream;
        cameraPermissionState = 'granted';
        cameraInitialized = true;
        document.getElementById('camera-preview').srcObject = stream;
        debugLog('✅ カメラ起動成功（低画質モード）');
      } catch (error) {
        showError('カメラエラー', 'カメラを起動できませんでした。');
      }
    }

    function showCameraPermissionGuide() {
      const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
      const isAndroid = /Android/.test(navigator.userAgent);
      
      let instructions = '';
      if (isIOS) {
        instructions = '【iOS設定方法】\n\n' +
          '1. iPhoneの「設定」を開く\n' +
          '2. 「LINE」を選択\n' +
          '3. 「カメラ」をONにする\n' +
          '4. LINEアプリに戻る\n' +
          '5. 下のボタンを押す';
      } else if (isAndroid) {
        instructions = '【Android設定方法】\n\n' +
          '1. 「設定」を開く\n' +
          '2. 「アプリ」→「LINE」を選択\n' +
          '3. 「権限」→「カメラ」を選択\n' +
          '4. 「許可」を選択\n' +
          '5. LINEアプリに戻る\n' +
          '6. 下のボタンを押す';
      } else {
        instructions = 'ブラウザの設定でカメラへのアクセスを許可してください。';
      }
      
      showError(
        'カメラの使用許可が必要です',
        instructions
      );
    }

    function stopCamera() {
      if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
        cameraInitialized = false;
        debugLog('カメラ停止');
      }
    }

    // ========================================
    // STEP 4: 撮影
    // ========================================
    function capturePhoto() {
      try {
        debugLog('撮影開始...');
        const video = document.getElementById('camera-preview');
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);
        
        originalCanvas = canvas;
        debugLog(`✅ 撮影完了 (${canvas.width}x${canvas.height})`);
        
        // デバイスのアルバムに保存
        saveToDevice(canvas);
        
        // カメラストリームは停止しない（再利用のため）
        showPreview();
      } catch (error) {
        debugLog(`❌ 撮影エラー: ${error.message}`);
        showError('撮影エラー', 'もう一度お試しください。');
      }
    }
    
    function saveToDevice(canvas) {
      try {
        canvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `aista_scan_${Date.now()}.jpg`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          debugLog('画像をデバイスに保存');
        }, 'image/jpeg', 0.95);
      } catch (error) {
        debugLog(`保存エラー: ${error.message}`);
        // 保存失敗しても処理は継続
      }
    }

    // ========================================
    // STEP 5: プレビュー表示
    // ========================================
    function showPreview() {
      showScreen('preview-screen');
      
      const previewCanvas = document.getElementById('preview-canvas');
      const maxWidth = window.innerWidth;
      const maxHeight = window.innerHeight * 0.5;
      
      const scale = Math.min(
        maxWidth / originalCanvas.width,
        maxHeight / originalCanvas.height
      );
      
      previewCanvas.width = originalCanvas.width * scale;
      previewCanvas.height = originalCanvas.height * scale;
      
      // トリミング枠初期化
      cropArea = {
        x: previewCanvas.width * 0.1,
        y: previewCanvas.height * 0.1,
        width: previewCanvas.width * 0.8,
        height: previewCanvas.height * 0.8
      };
      
      rotation = 0;
      brightness = 1.0;
      
      redrawPreview();
      debugLog('プレビュー表示完了');
    }

    // ========================================
    // STEP 6-7: 画像編集（明るさ・回転）
    // ========================================
    function redrawPreview() {
      const canvas = document.getElementById('preview-canvas');
      const ctx = canvas.getContext('2d');
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      
      // 回転
      if (rotation !== 0) {
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate((rotation * Math.PI) / 180);
        ctx.translate(-canvas.width / 2, -canvas.height / 2);
      }
      
      // 明るさ
      ctx.filter = `brightness(${brightness})`;
      
      // 画像描画
      ctx.drawImage(originalCanvas, 0, 0, canvas.width, canvas.height);
      ctx.restore();
      
      // トリミング枠描画
      drawCropArea(ctx);
    }

    // ========================================
    // STEP 8: トリミング枠描画
    // ========================================
    function drawCropArea(ctx) {
      const { x, y, width, height } = cropArea;
      
      // 半透明オーバーレイ
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      
      // 選択範囲をクリア
      ctx.clearRect(x, y, width, height);
      
      // 枠線
      ctx.strokeStyle = '#06c755';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, width, height);
      
      // ハンドル（4隅）
      const handleSize = 20;
      ctx.fillStyle = '#06c755';
      
      // 左上
      ctx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
      // 右上
      ctx.fillRect(x + width - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
      // 左下
      ctx.fillRect(x - handleSize / 2, y + height - handleSize / 2, handleSize, handleSize);
      // 右下
      ctx.fillRect(x + width - handleSize / 2, y + height - handleSize / 2, handleSize, handleSize);
    }

    // ========================================
    // STEP 9: トリミング操作
    // ========================================
    function getTouchPos(canvas, touch) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top
      };
    }

    function getHandleAt(x, y) {
      const handleSize = 20;
      const handles = [
        { name: 'tl', x: cropArea.x, y: cropArea.y },
        { name: 'tr', x: cropArea.x + cropArea.width, y: cropArea.y },
        { name: 'bl', x: cropArea.x, y: cropArea.y + cropArea.height },
        { name: 'br', x: cropArea.x + cropArea.width, y: cropArea.y + cropArea.height }
      ];
      
      for (const handle of handles) {
        if (Math.abs(x - handle.x) < handleSize && Math.abs(y - handle.y) < handleSize) {
          return handle.name;
        }
      }
      
      // 枠内かチェック
      if (x >= cropArea.x && x <= cropArea.x + cropArea.width &&
          y >= cropArea.y && y <= cropArea.y + cropArea.height) {
        return 'move';
      }
      
      return null;
    }

    document.getElementById('preview-canvas').addEventListener('touchstart', (e) => {
      e.preventDefault();
      const canvas = e.target;
      const touch = e.touches[0];
      const pos = getTouchPos(canvas, touch);
      
      dragTarget = getHandleAt(pos.x, pos.y);
      if (dragTarget) {
        isDragging = true;
        dragStartX = pos.x;
        dragStartY = pos.y;
      }
    });

    document.getElementById('preview-canvas').addEventListener('touchmove', (e) => {
      if (!isDragging || !dragTarget) return;
      e.preventDefault();
      
      const canvas = e.target;
      const touch = e.touches[0];
      const pos = getTouchPos(canvas, touch);
      
      const dx = pos.x - dragStartX;
      const dy = pos.y - dragStartY;
      
      const minSize = 50;
      
      if (dragTarget === 'move') {
        // 枠全体を移動
        cropArea.x = Math.max(0, Math.min(canvas.width - cropArea.width, cropArea.x + dx));
        cropArea.y = Math.max(0, Math.min(canvas.height - cropArea.height, cropArea.y + dy));
      } else if (dragTarget === 'tl') {
        const newX = Math.min(cropArea.x + cropArea.width - minSize, cropArea.x + dx);
        const newY = Math.min(cropArea.y + cropArea.height - minSize, cropArea.y + dy);
        cropArea.width += cropArea.x - newX;
        cropArea.height += cropArea.y - newY;
        cropArea.x = Math.max(0, newX);
        cropArea.y = Math.max(0, newY);
      } else if (dragTarget === 'tr') {
        const newWidth = Math.max(minSize, cropArea.width + dx);
        const newY = Math.min(cropArea.y + cropArea.height - minSize, cropArea.y + dy);
        cropArea.width = Math.min(canvas.width - cropArea.x, newWidth);
        cropArea.height += cropArea.y - newY;
        cropArea.y = Math.max(0, newY);
      } else if (dragTarget === 'bl') {
        const newX = Math.min(cropArea.x + cropArea.width - minSize, cropArea.x + dx);
        const newHeight = Math.max(minSize, cropArea.height + dy);
        cropArea.width += cropArea.x - newX;
        cropArea.x = Math.max(0, newX);
        cropArea.height = Math.min(canvas.height - cropArea.y, newHeight);
      } else if (dragTarget === 'br') {
        cropArea.width = Math.max(minSize, Math.min(canvas.width - cropArea.x, cropArea.width + dx));
        cropArea.height = Math.max(minSize, Math.min(canvas.height - cropArea.y, cropArea.height + dy));
      }
      
      dragStartX = pos.x;
      dragStartY = pos.y;
      
      redrawPreview();
    });

    document.getElementById('preview-canvas').addEventListener('touchend', () => {
      isDragging = false;
      dragTarget = null;
    });

    // ========================================
    // STEP 10: 画像送信
    // ========================================
    function generateFinalImage() {
      debugLog('最終画像生成開始...');
      
      const previewCanvas = document.getElementById('preview-canvas');
      const scale = originalCanvas.width / previewCanvas.width;
      
      // 実際のピクセル座標に変換
      const actualCrop = {
        x: cropArea.x * scale,
        y: cropArea.y * scale,
        width: cropArea.width * scale,
        height: cropArea.height * scale
      };
      
      const finalCanvas = document.createElement('canvas');
      finalCanvas.width = actualCrop.width;
      finalCanvas.height = actualCrop.height;
      
      const ctx = finalCanvas.getContext('2d');
      ctx.filter = `brightness(${brightness})`;
      
      // トリミング + 明るさ適用
      ctx.drawImage(
        originalCanvas,
        actualCrop.x, actualCrop.y, actualCrop.width, actualCrop.height,
        0, 0, actualCrop.width, actualCrop.height
      );
      
      debugLog(`最終画像サイズ: ${finalCanvas.width}x${finalCanvas.height}`);
      return finalCanvas;
    }

    function canvasToBase64(canvas, quality = 0.9) {
      return canvas.toDataURL('image/jpeg', quality).split(',')[1];
    }

    async function uploadImage() {
      try {
        showScreen('processing-screen');
        debugLog('送信処理開始...');
        
        const finalCanvas = generateFinalImage();
        const base64Data = canvasToBase64(finalCanvas);
        const imageSize = Math.round(base64Data.length * 0.75);
        
        debugLog(`画像エンコード完了 (${(imageSize / 1024 / 1024).toFixed(2)}MB)`);
        
        // サイズチェック
        if (imageSize > 10 * 1024 * 1024) {
          throw new Error('画像サイズが大きすぎます（10MB以下にしてください）');
        }
        
        const fileName = `scan_${Date.now()}.jpg`;
        
        const requestData = {
          userId,
          displayName,
          image: {
            fileName,
            imageData: base64Data,
            imageSize
          }
        };
        
        debugLog(`Workers送信: ${WORKER_URL}`);
        debugLog(`リクエストデータ: userId=${userId}, size=${(imageSize/1024/1024).toFixed(2)}MB`);
        
        const response = await fetch(WORKER_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestData)
        });
        
        // レスポンスボディを先に取得
        const responseText = await response.text();
        debugLog(`レスポンス受信: status=${response.status}`);
        
        if (!response.ok) {
          // より詳細なエラーメッセージを取得
          let errorDetail = response.statusText;
          try {
            const errorJson = JSON.parse(responseText);
            if (errorJson.error) {
              errorDetail = errorJson.error;
            }
          } catch (e) {
            // JSONパース失敗時はresponseTextをそのまま使う
            errorDetail = responseText || response.statusText;
          }
          
          debugLog(`❌ エラー詳細: ${errorDetail}`);
          throw new Error(errorDetail);
        }
        
        const result = JSON.parse(responseText);
        debugLog(`✅ 送信成功: ${JSON.stringify(result)}`);
        
        showScreen('complete-screen');
      } catch (error) {
        debugLog(`❌ 送信エラー: ${error.message}`);
        
        // エラーメッセージを分類
        let errorTitle = '送信に失敗しました';
        let errorMessage = error.message;
        
        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
          errorTitle = 'ネットワークエラー';
          errorMessage = 'インターネット接続を確認して、もう一度お試しください。';
        } else if (error.message.includes('GEMINI_API_KEY')) {
          errorTitle = '設定エラー';
          errorMessage = 'サーバーの設定に問題があります。管理者にお問い合わせください。\n\n詳細: Gemini APIキーが未設定';
        } else if (error.message.includes('LINE_CHANNEL_ACCESS_TOKEN')) {
          errorTitle = '設定エラー';
          errorMessage = 'サーバーの設定に問題があります。管理者にお問い合わせください。\n\n詳細: LINEトークンが未設定';
        } else if (error.message.includes('Gemini Vision API Error')) {
          errorTitle = 'AI処理エラー';
          errorMessage = '画像の解析に失敗しました。\n\n• より明るい場所で撮影してください\n• ピントを合わせて撮影してください\n• もう一度お試しください';
        } else if (error.message.includes('LINE API Error')) {
          errorTitle = 'LINE通知エラー';
          errorMessage = '処理は完了しましたが、LINEへの通知に失敗しました。';
        }
        
        showError(errorTitle, errorMessage);
      }
    }

    // ========================================
    // イベントリスナー
    // ========================================
    
    // 明るさスライダー
    document.getElementById('brightness-slider').addEventListener('input', (e) => {
      brightness = e.target.value / 100;
      document.getElementById('brightness-value').textContent = e.target.value + '%';
      redrawPreview();
    });

    // 回転ボタン
    document.getElementById('rotate-btn').addEventListener('click', () => {
      rotation = (rotation + 90) % 360;
      debugLog(`回転: ${rotation}度`);
      redrawPreview();
    });

    // 撮り直しボタン
    document.getElementById('retake-btn').addEventListener('click', async () => {
      showScreen('camera-screen');
      // ストリームは停止せず再利用
      if (cameraStream && cameraInitialized) {
        const video = document.getElementById('camera-preview');
        video.srcObject = cameraStream;
        debugLog('カメラストリーム再利用');
      } else {
        await initCamera();
      }
    });

    // 送信ボタン
    document.getElementById('send-btn').addEventListener('click', uploadImage);

    // シャッターボタン
    document.getElementById('shutter-btn').addEventListener('click', capturePhoto);

    // 新しくスキャンボタン
    document.getElementById('new-scan-btn').addEventListener('click', async () => {
      showScreen('camera-screen');
      // ストリームは停止せず再利用
      if (cameraStream && cameraInitialized) {
        const video = document.getElementById('camera-preview');
        video.srcObject = cameraStream;
        debugLog('カメラストリーム再利用');
      } else {
        await initCamera();
      }
    });

    // リトライボタン
    document.getElementById('retry-btn').addEventListener('click', async () => {
      // 拒否状態の場合は「再チェック」扱い
      if (cameraPermissionState === 'denied') {
        debugLog('設定変更確認 - 状態をリセット');
        cameraPermissionState = 'unchecked'; // 再チェック可能に
      }
      
      showScreen('camera-screen');
      await initCamera();
    });

    // アプリ終了時のみストリームを停止
    window.addEventListener('beforeunload', () => {
      stopCamera();
    });

    // ========================================
    // 初期化
    // ========================================
    window.addEventListener('DOMContentLoaded', async () => {
      debugLog('アプリ起動');
      
      const initialized = await initLiff();
      if (!initialized) return;
      
      showScreen('camera-screen');
      await initCamera();
    });
  </script>

</body>
</html>
