<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>アイスタ カメラスキャン</title>
  <script charset="utf-8" src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      overflow: hidden;
      background: #000;
      position: fixed;
      width: 100%;
      height: 100vh;
      height: 100dvh;
    }
    
    .screen {
      display: none;
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      flex-direction: column;
    }
    
    .screen.active {
      display: flex;
    }
    
    /* ========================================
     * カメラ画面
     * ======================================== */
    #camera-screen {
      background: #000;
      position: relative;
    }
    
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: transparent;
      padding: 15px;
      color: #fff;
      text-align: center;
      font-size: 16px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      text-shadow: 0 2px 8px rgba(0,0,0,0.8);
    }
    
    #camera-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
    }
    
    .camera-grid {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 5;
    }
    
    .grid-line {
      position: absolute;
      background: rgba(255, 255, 255, 0.3);
    }
    
    .grid-vertical-1,
    .grid-vertical-2 {
      width: 1px;
      height: 100%;
      top: 0;
    }
    
    .grid-vertical-1 { left: 33.33%; }
    .grid-vertical-2 { left: 66.66%; }
    
    .grid-horizontal-1,
    .grid-horizontal-2 {
      width: 100%;
      height: 1px;
      left: 0;
    }
    
    .grid-horizontal-1 { top: 33.33%; }
    .grid-horizontal-2 { top: 66.66%; }
    
    .camera-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: auto;
      background: transparent;
      padding: 20px 20px 30px 20px;
      text-align: center;
      z-index: 100;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      align-items: center;
      gap: 20px;
    }
    
    .hint {
      color: #fff;
      font-size: 12px;
      margin-bottom: 0;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8);
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 4px;
    }
    
    .camera-buttons {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 30px;
    }
    
    .camera-sub-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      border: 2px solid rgba(255,255,255,0.5);
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .camera-sub-btn:active {
      background: rgba(255,255,255,0.3);
    }
    
    .camera-sub-btn svg {
      width: 24px;
      height: 24px;
      stroke: #fff;
      stroke-width: 2;
      fill: none;
    }
    
    #shutter-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: #fff;
      border: 4px solid #000;
      cursor: pointer;
      transition: transform 0.1s;
      box-shadow: none;
    }
    
    #shutter-btn:active {
      transform: scale(0.95);
      background: #f0f0f0;
    }
    
    /* ========================================
     * 編集画面
     * ======================================== */
    #edit-screen {
      background: #333;
      position: relative;
    }
    
    .edit-container {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
    }
    
    .edit-message {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      padding: 10px 16px;
      border-radius: 20px;
      color: #fff;
      font-size: 13px;
      z-index: 5;
      pointer-events: none;
      white-space: nowrap;
    }
    
    #edit-canvas {
      max-width: 100%;
      max-height: 100%;
      touch-action: none;
    }
    
    .mode-buttons {
      position: absolute;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 10;
    }
    
    .mode-btn {
      padding: 8px 16px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      color: rgba(255,255,255,0.6);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 60px;
    }
    
    .mode-btn.active {
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.3);
      color: rgba(255,255,255,0.95);
      font-weight: 500;
    }
    
    .action-buttons {
      position: absolute;
      bottom: 20px;
      left: 15px;
      right: 15px;
      display: flex;
      gap: 10px;
      z-index: 10;
    }
    
    .btn-secondary {
      flex: 1;
      padding: 14px;
      background: rgba(0,0,0,0.75);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      line-height: 1.2;
    }
    
    .btn-primary {
      flex: 2;
      padding: 14px;
      background: #06c755;
      color: #fff;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      line-height: 1.2;
    }
    
    /* ========================================
     * 処理中画面
     * ======================================== */
    #processing-screen {
      background: #fff;
      align-items: center;
      justify-content: center;
    }
    
    .spinner {
      width: 60px;
      height: 60px;
      border: 4px solid #f0f0f0;
      border-top-color: #06c755;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .processing-text {
      font-size: 16px;
      color: #333;
      margin-bottom: 10px;
    }
    
    .processing-hint {
      font-size: 12px;
      color: #999;
    }
    
    /* ========================================
     * 完了画面
     * ======================================== */
    #complete-screen {
      background: #fff;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
    }
    
    .complete-title {
      font-size: 24px;
      font-weight: bold;
      color: #333;
      margin-bottom: 10px;
    }
    
    .complete-message {
      font-size: 14px;
      color: #666;
      text-align: center;
      margin-bottom: 30px;
      line-height: 1.6;
    }
    
    .complete-buttons {
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .action-btn {
      width: 100%;
      padding: 16px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .action-btn-primary {
      background: #06c755;
      color: #fff;
      font-weight: bold;
      box-shadow: 0 2px 8px rgba(6, 199, 85, 0.3);
    }
    
    .action-btn-primary:active {
      background: #05b349;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(6, 199, 85, 0.4);
    }
    
    .action-btn-secondary {
      background: #f5f5f5;
      color: #333;
      border: 1px solid #ddd;
      font-weight: 500;
      font-size: 15px;
    }
    
    .action-btn-secondary:active {
      background: #e8e8e8;
      border-color: #ccc;
    }
    
    /* ========================================
     * エラー画面
     * ======================================== */
    #error-screen {
      background: #fff;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
    }
    
    .error-title {
      font-size: 24px;
      font-weight: bold;
      color: #e74c3c;
      margin-bottom: 10px;
    }
    
    .error-detail {
      font-size: 14px;
      color: #666;
      text-align: center;
      margin-bottom: 30px;
      padding: 0 20px;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>

  <!-- カメラ画面 -->
  <div id="camera-screen" class="screen">
    <div class="header">カメラスキャン</div>
    <video id="camera-preview" autoplay playsinline></video>
    
    <div class="camera-grid">
      <div class="grid-line grid-vertical-1"></div>
      <div class="grid-line grid-vertical-2"></div>
      <div class="grid-line grid-horizontal-1"></div>
      <div class="grid-line grid-horizontal-2"></div>
    </div>
    
    <div class="camera-controls">
      <div class="hint">アイスタで解説してほしい問題を撮影しよう！</div>
      <div class="camera-buttons">
        <button id="album-btn" class="camera-sub-btn">
          <svg viewBox="0 0 24 24">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
            <circle cx="8.5" cy="8.5" r="1.5"/>
            <path d="M21 15l-5-5L5 21"/>
          </svg>
        </button>
        <button id="shutter-btn"></button>
        <button id="help-btn" class="camera-sub-btn">
          <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"/>
            <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
            <line x1="12" y1="17" x2="12.01" y2="17"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- 編集画面 -->
  <div id="edit-screen" class="screen">
    <div class="edit-container">
      <div class="edit-message">解説して欲しい部分を切り取ろう！</div>
      <canvas id="edit-canvas" width="360" height="640"></canvas>
    </div>
    
    <div class="mode-buttons">
      <button id="rotate-mode-btn" class="mode-btn active">回転</button>
      <button id="move-mode-btn" class="mode-btn">移動</button>
    </div>
    
    <div class="action-buttons">
      <button id="retake-btn" class="btn-secondary">撮り直し</button>
      <button id="send-btn" class="btn-primary">送信</button>
    </div>
  </div>

  <!-- 処理中画面 -->
  <div id="processing-screen" class="screen">
    <div class="spinner"></div>
    <div class="processing-text">文字起こし中...</div>
    <div class="processing-hint">20〜40秒ほどお待ちください</div>
  </div>

  <!-- 完了画面 -->
  <div id="complete-screen" class="screen">
    <div class="complete-title">処理完了</div>
    <div class="complete-message">
      文字起こし結果をLINEで送信しました。<br>
      トークをご確認ください。
    </div>
    <div class="complete-buttons">
      <button class="action-btn action-btn-primary" id="open-line-btn">LINEを開く</button>
      <button class="action-btn action-btn-secondary" id="new-scan-btn">もう一度スキャン</button>
    </div>
  </div>

  <!-- エラー画面 -->
  <div id="error-screen" class="screen">
    <div class="error-title" id="error-title">エラーが発生しました</div>
    <div class="error-detail" id="error-detail"></div>
    <button class="action-btn action-btn-primary" id="retry-btn">もう一度試す</button>
  </div>

  <script>
    // ========================================
    // 設定
    // ========================================
    const LIFF_ID = '2008304828-OnEyAwBm';
    const WORKER_URL = 'https://aista-document-processor.luminalice-reg-tea-sun-red-9b0.workers.dev/upload-image';
    const DEBUG_MODE = true;

    // Canvas設定
    const CANVAS_WIDTH = 360;
    const CANVAS_HEIGHT = 640;
    const CANVAS_CENTER_X = 180;
    const CANVAS_CENTER_Y = 320;

    // ハンドル設定
    const HANDLE_VISUAL_SIZE = 6;
    const HANDLE_TAP_AREA = 50;

    // 制約値
    const MIN_CROP_SIZE = 50;
    const ROTATION_RANGE = 180;
    const SCALE_MIN = 0.5;
    const SCALE_MAX = 3.0;
    const ROTATION_THRESHOLD = 10;

    // ========================================
    // グローバル状態管理
    // ========================================
    
    // LIFF認証情報
    let userId = null;
    let displayName = null;

    // カメラ関連
    let cameraStream = null;
    let cameraInitialized = false;
    let cameraPermissionState = 'unchecked';
    let audioContext = null;

    // 画像データ
    let originalCanvas = null;

    // 編集パラメータ
    let rotation = 0;
    let imageOffset = { x: 0, y: 0 };
    let imageScale = 1;
    let cropArea = { x: 30, y: 80, width: 300, height: 200 };

    // UI状態
    let editMode = 'rotate';

    // ドラッグ操作
    let isDragging = false;
    let dragTarget = null;
    let dragStartPos = { x: 0, y: 0 };
    let dragStartClient = { x: 0, y: 0 };

    // ジェスチャー
    let initialPinchDistance = 0;
    let isRotationGesture = false;
    let isMouseDown = false;

    // ========================================
    // ユーティリティ
    // ========================================
    function debugLog(message) {
      if (DEBUG_MODE) {
        const timestamp = new Date().toLocaleTimeString('ja-JP');
        console.log(`[${timestamp}] ${message}`);
      }
    }

    function showScreen(screenId) {
      debugLog(`画面遷移: ${screenId}`);
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      document.getElementById(screenId).classList.add('active');
    }

    function showError(title, detail) {
      debugLog(`エラー表示: ${title} - ${detail}`);
      document.getElementById('error-title').textContent = title;
      document.getElementById('error-detail').textContent = detail;
      showScreen('error-screen');
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    // ========================================
    // LIFF初期化
    // ========================================
    async function initLiff() {
      try {
        debugLog('LIFF初期化開始...');
        await liff.init({ liffId: LIFF_ID });
        
        if (!liff.isLoggedIn()) {
          debugLog('未ログイン → ログイン実行');
          liff.login();
          return false;
        }
        
        const profile = await liff.getProfile();
        userId = profile.userId;
        displayName = profile.displayName;
        debugLog(`✅ ユーザー情報取得: ${displayName} (${userId})`);
        
        return true;
      } catch (error) {
        debugLog(`❌ LIFF初期化エラー: ${error.message}`);
        showError('LIFF初期化エラー', 'LINEからアクセスしてください。');
        return false;
      }
    }

    // ========================================
    // 音声制御
    // ========================================
    function initAudioContext() {
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          debugLog('AudioContext初期化完了');
        }
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        gainNode.gain.value = 0.001;
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.001);
        
        debugLog('無音オーディオ再生完了');
      } catch (error) {
        debugLog(`AudioContext初期化エラー: ${error.message}`);
      }
    }

    // ========================================
    // カメラ起動
    // ========================================
    async function initCamera() {
      if (cameraStream && cameraInitialized) {
        debugLog('カメラストリーム再利用');
        const video = document.getElementById('camera-preview');
        video.srcObject = cameraStream;
        return;
      }
      
      if (cameraPermissionState === 'denied') {
        debugLog('カメラ拒否済み - 案内表示');
        showCameraPermissionGuide();
        return;
      }
      
      try {
        debugLog('カメラ初期化開始...');
        initAudioContext();
        
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          }
        });
        
        cameraStream = stream;
        cameraPermissionState = 'granted';
        cameraInitialized = true;
        
        const video = document.getElementById('camera-preview');
        video.volume = 0;
        video.muted = true;
        video.srcObject = stream;
        
        video.addEventListener('loadedmetadata', () => {
          debugLog(`✅ カメラ起動成功: ${video.videoWidth}x${video.videoHeight}`);
        }, { once: true });
        
      } catch (error) {
        handleCameraError(error);
      }
    }

    function handleCameraError(error) {
      debugLog(`カメラエラー: ${error.name} - ${error.message}`);
      
      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
        cameraPermissionState = 'denied';
        showCameraPermissionGuide();
      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
        showError('カメラが見つかりません', 'お使いの端末にはカメラが搭載されていないか、接続されていません。');
      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
        showError('カメラにアクセスできません', '他のアプリがカメラを使用している可能性があります。\n他のアプリを終了してから再度お試しください。');
      } else {
        showError('カメラエラー', error.message);
      }
    }

    function showCameraPermissionGuide() {
      const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
      const isAndroid = /Android/.test(navigator.userAgent);
      
      let instructions = '';
      if (isIOS) {
        instructions = '【iOS設定方法】\n\n' +
          '1. iPhoneの「設定」を開く\n' +
          '2. 「LINE」を選択\n' +
          '3. 「カメラ」をONにする\n' +
          '4. LINEアプリに戻る\n' +
          '5. 下のボタンを押す';
      } else if (isAndroid) {
        instructions = '【Android設定方法】\n\n' +
          '1. 「設定」を開く\n' +
          '2. 「アプリ」→「LINE」を選択\n' +
          '3. 「権限」→「カメラ」を選択\n' +
          '4. 「許可」を選択\n' +
          '5. LINEアプリに戻る\n' +
          '6. 下のボタンを押す';
      } else {
        instructions = 'ブラウザの設定でカメラへのアクセスを許可してください。';
      }
      
      showError('カメラの使用許可が必要です', instructions);
    }

    // ========================================
    // アルバムから画像選択
    // ========================================
    async function selectFromAlbum() {
      try {
        debugLog('アルバム選択開始...');
        
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        
        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          
          debugLog(`ファイル選択: ${file.name}`);
          
          const reader = new FileReader();
          reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              
              originalCanvas = canvas;
              debugLog(`✅ アルバム画像読込完了: ${canvas.width}x${canvas.height}`);
              
              showEditScreen();
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        };
        
        input.click();
      } catch (error) {
        debugLog(`❌ アルバム選択エラー: ${error.message}`);
        showError('アルバム選択エラー', 'もう一度お試しください。');
      }
    }

    // ========================================
    // ヘルプページを開く
    // ========================================
    function openHelp() {
      debugLog('ヘルプページを開く');
      // 仮リンク（実際のヘルプページURLに変更）
      window.open('https://example.com/help', '_blank');
    }

    // ========================================
    // 撮影
    // ========================================
    function showFlashEffect() {
      const flash = document.createElement('div');
      flash.style.cssText = `
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: white;
        opacity: 0;
        z-index: 9999;
        pointer-events: none;
        transition: opacity 0.15s ease-out;
      `;
      document.body.appendChild(flash);
      
      requestAnimationFrame(() => {
        flash.style.opacity = '0.8';
        setTimeout(() => {
          flash.style.opacity = '0';
          setTimeout(() => flash.remove(), 150);
        }, 50);
      });
    }

    function capturePhoto() {
      try {
        debugLog('撮影開始...');
        
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
        }
        
        showFlashEffect();
        
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
        
        const video = document.getElementById('camera-preview');
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);
        
        originalCanvas = canvas;
        debugLog(`✅ 撮影完了: ${canvas.width}x${canvas.height}`);
        
        showEditScreen();
      } catch (error) {
        debugLog(`❌ 撮影エラー: ${error.message}`);
        showError('撮影エラー', 'もう一度お試しください。');
      }
    }

    // ========================================
    // 編集画面表示
    // ========================================
    function showEditScreen() {
      if (!originalCanvas) {
        showError('画像データがありません', 'もう一度撮影してください');
        return;
      }
      
      // 編集パラメータ初期化
      rotation = 0;
      imageOffset = { x: 0, y: 0 };
      imageScale = 1;
      
      const scale = Math.min(
        window.innerWidth / originalCanvas.width,
        (window.innerHeight * 0.7) / originalCanvas.height
      );
      
      const canvas = document.getElementById('edit-canvas');
      canvas.width = CANVAS_WIDTH;
      canvas.height = CANVAS_HEIGHT;
      
      cropArea = {
        x: CANVAS_WIDTH * 0.1,
        y: CANVAS_HEIGHT * 0.1,
        width: CANVAS_WIDTH * 0.8,
        height: CANVAS_HEIGHT * 0.8
      };
      
      editMode = 'rotate';
      updateModeButtons();
      
      showScreen('edit-screen');
      drawEditCanvas();
      
      debugLog('編集画面表示完了');
    }

    // ========================================
    // Canvas描画
    // ========================================
    function drawEditCanvas() {
      const canvas = document.getElementById('edit-canvas');
      if (!canvas || !originalCanvas) return;
      
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      
      // 暗い背景画像
      drawImageWithTransform(ctx);
      
      // 黒オーバーレイ
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      
      // トリミング内を明るく
      ctx.save();
      ctx.beginPath();
      ctx.rect(cropArea.x, cropArea.y, cropArea.width, cropArea.height);
      ctx.clip();
      drawImageWithTransform(ctx);
      ctx.restore();
      
      // ハンドル描画
      drawCropHandles(ctx);
    }

    function drawImageWithTransform(ctx) {
      ctx.save();
      
      ctx.translate(CANVAS_CENTER_X + imageOffset.x, CANVAS_CENTER_Y + imageOffset.y);
      ctx.scale(imageScale, imageScale);
      ctx.rotate((rotation * Math.PI) / 180);
      ctx.translate(-CANVAS_CENTER_X, -CANVAS_CENTER_Y);
      
      ctx.drawImage(originalCanvas, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      
      ctx.restore();
    }

    function drawCropHandles(ctx) {
      ctx.save();
      ctx.imageSmoothingEnabled = false;
      
      const positions = [
        [cropArea.x, cropArea.y],
        [cropArea.x + cropArea.width, cropArea.y],
        [cropArea.x, cropArea.y + cropArea.height],
        [cropArea.x + cropArea.width, cropArea.y + cropArea.height]
      ];
      
      positions.forEach(([x, y]) => {
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(Math.round(x), Math.round(y), HANDLE_VISUAL_SIZE, 0, Math.PI * 2);
        ctx.fill();
      });
      
      ctx.restore();
    }

    // ========================================
    // 編集操作 - イベントハンドラー
    // ========================================
    function getCanvasPosition(e) {
      const container = document.querySelector('.edit-container');
      const rect = container.getBoundingClientRect();
      const canvas = document.getElementById('edit-canvas');
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY,
        clientX,
        clientY
      };
    }

    function calculatePinchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function detectHandle(x, y) {
      const handles = [
        { name: 'tl', x: cropArea.x, y: cropArea.y },
        { name: 'tr', x: cropArea.x + cropArea.width, y: cropArea.y },
        { name: 'bl', x: cropArea.x, y: cropArea.y + cropArea.height },
        { name: 'br', x: cropArea.x + cropArea.width, y: cropArea.y + cropArea.height }
      ];
      
      for (const handle of handles) {
        const distance = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
        if (distance < HANDLE_TAP_AREA) {
          return handle.name;
        }
      }
      return null;
    }

    function isInsideCropArea(x, y) {
      return x >= cropArea.x && x <= cropArea.x + cropArea.width &&
             y >= cropArea.y && y <= cropArea.y + cropArea.height;
    }

    function handleEditPointerDown(e) {
      const isTouch = e.type === 'touchstart';
      if (!isTouch) isMouseDown = true;
      
      e.preventDefault();
      
      const pos = getCanvasPosition(e);
      dragStartPos = { x: pos.x, y: pos.y };
      dragStartClient = { x: pos.clientX, y: pos.clientY };
      
      // 優先度1: ピンチ
      if (isTouch && e.touches.length === 2) {
        initialPinchDistance = calculatePinchDistance(e.touches);
        dragTarget = 'pinch';
        isDragging = true;
        return;
      }
      
      // 優先度2: ハンドル
      const handle = detectHandle(pos.x, pos.y);
      if (handle) {
        dragTarget = handle;
        isDragging = true;
        return;
      }
      
      // 優先度3: 枠内
      if (isInsideCropArea(pos.x, pos.y)) {
        dragTarget = 'move';
        isDragging = true;
        return;
      }
      
      // 優先度4: 移動モード時の枠外
      if (editMode === 'move') {
        dragTarget = 'image';
        isDragging = true;
      }
    }

    function handleEditPointerMove(e) {
      const isTouch = e.type === 'touchmove';
      if (!isTouch && !isMouseDown) return;
      
      e.preventDefault();
      
      const pos = getCanvasPosition(e);
      
      // ピンチ
      if (dragTarget === 'pinch' && isTouch && e.touches.length === 2) {
        const currentDistance = calculatePinchDistance(e.touches);
        const scaleRatio = currentDistance / initialPinchDistance;
        imageScale = clamp(imageScale * scaleRatio, SCALE_MIN, SCALE_MAX);
        initialPinchDistance = currentDistance;
        drawEditCanvas();
        return;
      }
      
      // ドラッグ操作
      if (isDragging && dragTarget) {
        const dx = pos.x - dragStartPos.x;
        const dy = pos.y - dragStartPos.y;
        
        if (dragTarget === 'image') {
          imageOffset.x += dx;
          imageOffset.y += dy;
        } else if (dragTarget === 'move') {
          cropArea.x = clamp(cropArea.x + dx, 0, CANVAS_WIDTH - cropArea.width);
          cropArea.y = clamp(cropArea.y + dy, 0, CANVAS_HEIGHT - cropArea.height);
        } else if (['tl', 'tr', 'bl', 'br'].includes(dragTarget)) {
          updateCropAreaCorner(dragTarget, dx, dy);
        }
        
        dragStartPos = { x: pos.x, y: pos.y };
        drawEditCanvas();
        return;
      }
      
      // 回転ジェスチャー
      if (editMode === 'rotate' && !isDragging) {
        const deltaX = pos.clientX - dragStartClient.x;
        
        if (!isRotationGesture && Math.abs(deltaX) > ROTATION_THRESHOLD) {
          isRotationGesture = true;
        }
        
        if (isRotationGesture) {
          rotation = clamp(Math.round(deltaX / 2), -ROTATION_RANGE, ROTATION_RANGE);
          drawEditCanvas();
        }
      }
    }

    function handleEditPointerUp() {
      isDragging = false;
      dragTarget = null;
      isMouseDown = false;
      isRotationGesture = false;
    }

    function updateCropAreaCorner(corner, dx, dy) {
      switch (corner) {
        case 'tl':
          const newTlX = clamp(cropArea.x + dx, 0, cropArea.x + cropArea.width - MIN_CROP_SIZE);
          const newTlY = clamp(cropArea.y + dy, 0, cropArea.y + cropArea.height - MIN_CROP_SIZE);
          cropArea.width += cropArea.x - newTlX;
          cropArea.height += cropArea.y - newTlY;
          cropArea.x = newTlX;
          cropArea.y = newTlY;
          break;
        case 'tr':
          const newTrY = clamp(cropArea.y + dy, 0, cropArea.y + cropArea.height - MIN_CROP_SIZE);
          cropArea.width = clamp(cropArea.width + dx, MIN_CROP_SIZE, CANVAS_WIDTH - cropArea.x);
          cropArea.height += cropArea.y - newTrY;
          cropArea.y = newTrY;
          break;
        case 'bl':
          const newBlX = clamp(cropArea.x + dx, 0, cropArea.x + cropArea.width - MIN_CROP_SIZE);
          cropArea.width += cropArea.x - newBlX;
          cropArea.x = newBlX;
          cropArea.height = clamp(cropArea.height + dy, MIN_CROP_SIZE, CANVAS_HEIGHT - cropArea.y);
          break;
        case 'br':
          cropArea.width = clamp(cropArea.width + dx, MIN_CROP_SIZE, CANVAS_WIDTH - cropArea.x);
          cropArea.height = clamp(cropArea.height + dy, MIN_CROP_SIZE, CANVAS_HEIGHT - cropArea.y);
          break;
      }
    }

    // ========================================
    // 最終画像生成・送信
    // ========================================
    function generateFinalImage() {
      debugLog('最終画像生成開始...');
      
      const canvas = document.getElementById('edit-canvas');
      const scale = originalCanvas.width / canvas.width;
      
      const actualCrop = {
        x: cropArea.x * scale,
        y: cropArea.y * scale,
        width: cropArea.width * scale,
        height: cropArea.height * scale
      };
      
      const finalCanvas = document.createElement('canvas');
      finalCanvas.width = actualCrop.width;
      finalCanvas.height = actualCrop.height;
      
      const ctx = finalCanvas.getContext('2d');
      ctx.save();
      ctx.translate(finalCanvas.width / 2, finalCanvas.height / 2);
      ctx.scale(imageScale, imageScale);
      ctx.rotate((rotation * Math.PI) / 180);
      ctx.translate(-finalCanvas.width / 2, -finalCanvas.height / 2);
      
      ctx.drawImage(
        originalCanvas,
        actualCrop.x, actualCrop.y, actualCrop.width, actualCrop.height,
        0, 0, finalCanvas.width, finalCanvas.height
      );
      
      ctx.restore();
      
      debugLog(`最終画像サイズ: ${finalCanvas.width}x${finalCanvas.height}`);
      return finalCanvas;
    }

    async function uploadImage() {
      try {
        showScreen('processing-screen');
        debugLog('送信処理開始...');
        
        const finalCanvas = generateFinalImage();
        const base64Data = finalCanvas.toDataURL('image/jpeg', 0.9).split(',')[1];
        const imageSize = Math.round(base64Data.length * 0.75);
        
        debugLog(`画像エンコード完了 (${(imageSize / 1024 / 1024).toFixed(2)}MB)`);
        
        if (imageSize > 10 * 1024 * 1024) {
          throw new Error('画像サイズが大きすぎます（10MB以下にしてください）');
        }
        
        const fileName = `scan_${Date.now()}.jpg`;
        
        const requestData = {
          userId,
          displayName,
          image: {
            fileName,
            imageData: base64Data,
            imageSize
          }
        };
        
        debugLog(`Workers送信: ${WORKER_URL}`);
        
        const response = await fetch(WORKER_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestData)
        });
        
        const responseText = await response.text();
        debugLog(`レスポンス受信: status=${response.status}`);
        
        if (!response.ok) {
          let errorDetail = response.statusText;
          try {
            const errorJson = JSON.parse(responseText);
            if (errorJson.error) errorDetail = errorJson.error;
          } catch (e) {
            errorDetail = responseText || response.statusText;
          }
          throw new Error(errorDetail);
        }
        
        const result = JSON.parse(responseText);
        debugLog(`✅ 送信成功: ${JSON.stringify(result)}`);
        
        showScreen('complete-screen');
      } catch (error) {
        debugLog(`❌ 送信エラー: ${error.message}`);
        
        let errorTitle = '送信に失敗しました';
        let errorMessage = error.message;
        
        if (error.message.includes('Failed to fetch')) {
          errorTitle = 'ネットワークエラー';
          errorMessage = 'インターネット接続を確認して、もう一度お試しください。';
        }
        
        showError(errorTitle, errorMessage);
      }
    }

    // ========================================
    // UI制御
    // ========================================
    function updateModeButtons() {
      document.getElementById('rotate-mode-btn').classList.toggle('active', editMode === 'rotate');
      document.getElementById('move-mode-btn').classList.toggle('active', editMode === 'move');
    }

    // ========================================
    // イベントリスナー
    // ========================================
    
    // カメラ
    document.getElementById('album-btn').addEventListener('click', selectFromAlbum);
    document.getElementById('shutter-btn').addEventListener('click', capturePhoto);
    document.getElementById('help-btn').addEventListener('click', openHelp);
    
    // 編集 - Canvas
    const editCanvas = document.getElementById('edit-canvas');
    editCanvas.addEventListener('touchstart', handleEditPointerDown);
    editCanvas.addEventListener('touchmove', handleEditPointerMove);
    editCanvas.addEventListener('touchend', handleEditPointerUp);
    editCanvas.addEventListener('mousedown', handleEditPointerDown);
    editCanvas.addEventListener('mousemove', handleEditPointerMove);
    editCanvas.addEventListener('mouseup', handleEditPointerUp);
    editCanvas.addEventListener('mouseleave', handleEditPointerUp);
    
    // 編集 - モード切替
    document.getElementById('rotate-mode-btn').addEventListener('click', () => {
      editMode = 'rotate';
      updateModeButtons();
    });
    document.getElementById('move-mode-btn').addEventListener('click', () => {
      editMode = 'move';
      updateModeButtons();
    });
    
    // 編集 - アクション
    document.getElementById('retake-btn').addEventListener('click', () => {
      showScreen('camera-screen');
      if (cameraStream && cameraInitialized) {
        const video = document.getElementById('camera-preview');
        video.srcObject = cameraStream;
      } else {
        initCamera();
      }
    });
    
    document.getElementById('send-btn').addEventListener('click', uploadImage);
    
    // 完了・エラー
    document.getElementById('open-line-btn').addEventListener('click', () => {
      debugLog('LINEを開くボタン押下');
      if (liff.isInClient()) {
        liff.closeWindow();
      } else {
        window.location.href = 'https://line.me/R/';
      }
    });
    
    document.getElementById('new-scan-btn').addEventListener('click', () => {
      showScreen('camera-screen');
      if (cameraStream && cameraInitialized) {
        const video = document.getElementById('camera-preview');
        video.srcObject = cameraStream;
      } else {
        initCamera();
      }
    });
    
    document.getElementById('retry-btn').addEventListener('click', () => {
      if (cameraPermissionState === 'denied') {
        cameraPermissionState = 'unchecked';
      }
      showScreen('camera-screen');
      initCamera();
    });

    // ========================================
    // 初期化
    // ========================================
    window.addEventListener('DOMContentLoaded', async () => {
      debugLog('アプリ起動');
      
      const initialized = await initLiff();
      if (!initialized) return;
      
      showScreen('camera-screen');
      await initCamera();
    });
  </script>

</body>
</html>
